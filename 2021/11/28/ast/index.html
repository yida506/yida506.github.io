



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="菜b的爬虫记录" href="http://yida506.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="菜b的爬虫记录" href="http://yida506.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="菜b的爬虫记录" href="http://yida506.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://yida506.github.io/2021/11/28/ast/">



  <title>
AST语法树 - ast |
Yume Shoka = 菜b的爬虫记录</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">AST语法树
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2021-11-28 21:38:27">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2021-11-28T21:38:27+08:00">2021-11-28</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Yume Shoka</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipev1x5e4j20zk0m8b29.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipet4bz0yj20zk0m8e81.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipewf5l51j20zk0m8b29.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipewkhf1zj20zk0m81kx.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciukx8a7j20zk0m8aio.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeun65urj20zk0m81ii.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/ast/" itemprop="item" rel="index" title="In ast"><span itemprop="name">ast</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="http://yida506.github.io/2021/11/28/ast/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="Mr2">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="菜b的爬虫记录">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h3 id="AST语法树介绍"><a href="#AST语法树介绍" class="headerlink" title="AST语法树介绍"></a>AST语法树介绍</h3><p>AST全称Abstract Syntax Tree,中文名称为抽象语法树,主要原理就是把代码通过词法分析和句法分析转化为一颗树的形式，对于树来讲又包含很多节点，其中包含了变量的位置,类别,值等一些参数。</p>
<p>例如：</p>
<pre><code class="javascript">var a = 3;
</code></pre>
<p>对应的AST解析结果为(采用Babel解析，结果只取body.declarations中的内容):</p>
<pre><code class="json">Node &#123;
  type: &#39;VariableDeclarator&#39;,
  start: 4,
  end: 9,
  loc: SourceLocation &#123;
    start: Position &#123; line: 1, column: 4 &#125;,
    end: Position &#123; line: 1, column: 9 &#125;,
    filename: undefined,
    identifierName: undefined
  &#125;,
  id: Node &#123;
    type: &#39;Identifier&#39;,
    start: 4,
    end: 5,
    loc: SourceLocation &#123;
      start: [Position],
      end: [Position],
      filename: undefined,
      identifierName: &#39;a&#39;
    &#125;,
    name: &#39;a&#39;
  &#125;,
  init: Node &#123;
    type: &#39;NumericLiteral&#39;,
    start: 8,
    end: 9,
    loc: SourceLocation &#123;
      start: [Position],
      end: [Position],
      filename: undefined,
      identifierName: undefined
    &#125;,
    extra: &#123; rawValue: 3, raw: &#39;3&#39; &#125;,
    value: 3
  &#125;
&#125;
</code></pre>
<p>上述将代码解析为了三块，第一块的type为’VariableDeclarator’，对应var,第二块为Identifier为对应的变量a,第三块为NumericLiteral，为对应的数字3。</p>
<p>这样就把js代码解析成了树的结构，然后就可以根据遍历的方式，提取，修改其中的值。</p>
<h3 id="本地运行babel"><a href="#本地运行babel" class="headerlink" title="本地运行babel"></a>本地运行babel</h3><p>运行babel首先需要安装babel的库。</p>
<pre><code>npm install @babel/parser
npm install @babel/traverse
npm install @babel/generator
</code></pre>
<p>parser主要是用于将代码解析成语法树的形式，traverse主要是用于遍历语法树节点，generator主要是用于将语法树解析回js代码。</p>
<h4 id="parser用法"><a href="#parser用法" class="headerlink" title="parser用法"></a>parser用法</h4><p>导包：</p>
<pre><code class="javascript">const &#123;parse&#125; = require(&#39;@babel/parser&#39;); 
</code></pre>
<p>由于我们需要用的是parser这个包中的parse函数，而parser又是一个对象，所以我们采用{}的方式只导入parse方法。</p>
<p>然后我们就可以直接的采用以下方式，就可以直接将js代码转化为ast树。</p>
<pre><code class="javascript">parse(&#39;js_code&#39;);
</code></pre>
<h4 id="traverse用法"><a href="#traverse用法" class="headerlink" title="traverse用法"></a>traverse用法</h4><p> 导包：</p>
<pre><code class="javascript">const traverse = require(&quot;@babel/traverse&quot;).default;
</code></pre>
<p>这里是取出的traverse包中的默认方法.</p>
<p>traverse方法需要两个参数，一个是ast树的对象，一个是要遍历对象。</p>
<pre><code class="javascript">const visitor = &#123;
    NumericLiteral(path) &#123;
        path.node.value = 100;
        console.log(path.node.value);
    &#125;
&#125;;
traverse(ast_code, visitor);
</code></pre>
<p>上述通过将ast树中的属性为NumericLiteral的节点的值批量替换成了100。</p>
<h4 id="generator用法"><a href="#generator用法" class="headerlink" title="generator用法"></a>generator用法</h4><p>导包:</p>
<pre><code class="javascript">const generator = require(&quot;@babel/generator&quot;).default;
</code></pre>
<p>与traverse类似，调用的包中的默认方法。</p>
<pre><code class="javascript">generator(ast_code).code
</code></pre>
<p>这样就把语法树修改回js的代码样式,然后再另存即可。</p>
<h4 id="types用法"><a href="#types用法" class="headerlink" title="types用法"></a>types用法</h4><p>导包：</p>
<pre><code class="javascript">const types = require(&quot;@babel/types&quot;);
</code></pre>
<p>types主要用于判断节点类型。</p>
<blockquote>
<p>example: types.isStringLiteral(Node) 判断该节点是不是字符类型.</p>
</blockquote>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>node和path的区别:</p>
<p>path代表的是traverse的路径之类的东西，node是path中的一个属性，代表的是具体遍历到的位置，通常我们直接使用node就可以对节点进行增删查改的操作。</p>
<p>scope解释</p>
<ul>
<li>path.scope可以输出当前作用域</li>
<li>path.scope.dumps可以输出当前作用域以及其节点的作用域。</li>
<li>在path.scope中包含多种属性，我们通常关注binding。</li>
</ul>
<p>对于每一个变量的binding包括4种信息，constant是否会被修改，refererces被修改的次数，violations被重新定义的次数，Kind表明类型。</p>
<h3 id="AST插件"><a href="#AST插件" class="headerlink" title="AST插件"></a>AST插件</h3><h4 id="常量混淆"><a href="#常量混淆" class="headerlink" title="常量混淆"></a>常量混淆</h4><p>所谓常量混淆主要指的是，将变量的属性用ASCII码，16进制码的方式代替，由于Js的特性，在运行时，会自动的将其解析成实际的值，但是在我们看来，会造成分析的不便。</p>
<p>在ast语法树中，类似的StringLiteral节点中包含extra节点，其中extra中包含了rawvalue,raw的属性，rawvalue对应的是其展示的值，与value的值相对应，raw包含的是ASCII码、Unicode编码类似的，输入的值。在该处extra节点是无意义的，删掉就可以返回实际的value.</p>
<pre><code class="javascript">StringLiteral(path) &#123;
        if(path.node.extra)&#123;
            console.log(path.node.extra);
            //将其直接置换为未定义，即可删除该节点。
            path.node.extra = undefined;
        &#125;
    &#125;
</code></pre>
<h4 id="常量折叠"><a href="#常量折叠" class="headerlink" title="常量折叠"></a>常量折叠</h4><p>对于常量折叠来讲，在解除了常量混淆后，我们希望看到类似的’par’+’se’ 直接变成’parse’的形式，这样就需要用到常量折叠的方式。</p>
<p>常量折叠可以抽象为如下几个步骤：</p>
<ol>
<li>筛选操作节点</li>
<li>声明节点属性</li>
<li>判断节点类型</li>
<li>计算</li>
<li>替换</li>
</ol>
<pre><code class="javascript">//对于字符串类型的常量堆叠
BinaryExpression(path)&#123;
           //筛选操作节点
        let left = path.node.left;
        let right = path.node.right;
        //字符串类型判断
        if(types.isStringLiteral(left)||types.isStringLiteral(right))&#123;
            // console.log(left.value + right.value);
            // path.evaluate()为节点计算，自动相加里面的value,得出三个参数：confident:true为可相加,deopt:暂时不清楚,value:加后的值
            //计算
            const &#123;value&#125; = path.evaluate();
            // console.log(path.evaluate());
            //替换
            path.replaceInline(types.valueToNode(value));
        &#125;

    &#125;
</code></pre>
<h4 id="函数还原"><a href="#函数还原" class="headerlink" title="函数还原"></a>函数还原</h4><p>所谓函数还原，就是针对只包含return，且作用域中只包含传入的参数的函数进行替换的操作，达到减少分析量的作用。</p>
<pre><code class="javascript">function add(a,b)&#123;
      return a + b;
&#125;
var c = add(3,4) + add(4,5)
</code></pre>
<p>最终目的是将其直接还原成 let c &#x3D; 3 + 4 + 4 + 5;的形式。</p>
<p>将上述代码通过babel解析后，发现，上述是由两个部分构成的，</p>
<p>1.FunctionDeclaration</p>
<p>2.VariableDeclaration</p>
<p>由于函数作用域的特性，我们在对函数还原的时候，往往需要遍历函数表达式，函数表达式的关联节点为对应的调用位置（对scope中的binding调用referencePaths方法）,然后上述对应的指向为add，接着就需要将其转移到父节点（add(3,4))的位置进行还原。</p>
<pre><code class="javascript">const fast_run = &#123;
    FunctionDeclaration(path)&#123;
        const &#123;id,body&#125; = path.node;
        //获取函数作用域集
        const binding = path.scope.getBinding(id.name);
        //获取作用域关联集(函数调用集)
        let referpaths = binding.referencePaths;
        // console.log(referpaths.toString());
        //单个选中
        //将函数表达式加入内存中
        eval(path.toString());
        for(const referpath of referpaths)&#123;
            //作用域关联到的对象只有调用对象,不包含具体的调用表达式,所以需要获取其父节点,然后就可已得到调用表达式,接着就是将调用表达式中的内容直接还原
            let callExpression = referpath.parentPath;
            //直接调用函数表达式,获取其值
            let value = eval(callExpression.toString());
            // console.log(callExpression.toString()+&#39;-&gt;&#39;+value);
            callExpression.replaceWith(types.valueToNode(value));
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a>控制流平坦化</h4><p>所谓控制流平坦化，就是将类while|switch、case的结构平坦化，可以直接的看到运行流程，这里以一个简要的平坦化过程为例。</p>
<pre><code class="javascript">var arr = [2,1,0];
var a = 0;
while(!![])&#123;
    switch (arr[a++]) &#123;
        case 0:
            console.log(0);
            continue;
        case 1:
            console.log(1);
            continue;
        case 2:
            console.log(2);
    &#125;
    break;
&#125;
</code></pre>
<p>上述AST解析后，由3块构成:</p>
<ol>
<li>VariableDeclaration</li>
<li>VariableDeclaration</li>
<li>WhileStatement</li>
</ol>
<p>在这里，我们需要对WhileStatement中的内容进行遍历，由于顺序已经知道，这里直接采用,针对改代码的插件如下：</p>
<pre><code class="javascript">const switch_visitor = &#123;
    WhileStatement(path)&#123;
        //当前while块对应的节点
        const cur_node = path.node;
        //body中包含两块，一块为switch块,另一块为break块,根据索引提取switch块,
        var switch_cell = cur_node.body.body[0];
        //获取数组,针对不同情况需要重新定义
        var arr = [2,1,0];
        //获取case块
        var case_list = switch_cell.cases;
        //建立数组用于保存后续值
        var temp_arr_switch_case = [];
        //数组映射,按给定数组顺序
        arr.map(targetIndex =&gt;&#123;
            //获取case中的部分,删除continue节点，然后将剩余节点添加进数组
            var targetBody = case_list[targetIndex].consequent;
            if (types.isContinueStatement(targetBody[targetBody.length - 1]))&#123;
                    targetBody.pop();
                &#125;
            temp_arr_switch_case = temp_arr_switch_case.concat(targetBody);
        &#125;);
        path.replaceWithMultiple(temp_arr_switch_case);
    &#125;
&#125;
</code></pre>
<p>上述代码中，对于数组部分，是直接采用的已经给定的数组，若要使插件适用性增加，需要优化获取数组，以及对是否包含控制流进行判断。</p>
<p>还原后的结果如下：</p>
<pre><code class="javascript">var arr = [2, 1, 0];
var a = 0;
console.log(2);
console.log(1);
console.log(0);
</code></pre>
<h3 id="初探OB混淆"><a href="#初探OB混淆" class="headerlink" title="初探OB混淆"></a>初探OB混淆</h3><p>在此以简单的Ob为例。</p>
<pre><code class="javascript">function hi() &#123;
  console.log(&quot;Hello World!&quot;);
&#125;
hi();
</code></pre>
<p>在<span class="exturl" data-url="aHR0cHM6Ly93d3cub2JmdXNjYXRvci5pby8=">JavaScript Obfuscator Tool</span>网站经过默认的混淆后结果如下：</p>
<pre><code class="javascript">var _0x30bb = [&#39;log&#39;, &#39;Hello\x20World!&#39;];

(function (_0x38d89d, _0x30bbb2) &#123;
    var _0xae0a32 = function (_0x2e4e9d) &#123;
        while (--_0x2e4e9d) &#123;
            _0x38d89d[&#39;push&#39;](_0x38d89d[&#39;shift&#39;]());
        &#125;
    &#125;;
    _0xae0a32(++_0x30bbb2);
&#125;(_0x30bb, 0x153));

var _0xae0a = function (_0x38d89d, _0x30bbb2) &#123;
    _0x38d89d = _0x38d89d - 0x0;
    var _0xae0a32 = _0x30bb[_0x38d89d];
    return _0xae0a32;
&#125;;

function hi() &#123;
    console[_0xae0a(&#39;0x1&#39;)](_0xae0a(&#39;0x0&#39;));
&#125;

hi();
</code></pre>
<p>可以看到，一个单纯的hello world被混淆成了这样,为后续分析增加了难度。将代码放入ast在线解析网址解析，可以发现上述主要被分为了5给代码块，按顺序依次为：</p>
<ol>
<li>VariableDeclaration</li>
<li>ExpressionStatement</li>
<li>FunctionDeclaration</li>
<li>FunctionDeclaration</li>
<li>ExpressionStatement</li>
</ol>
<p>其中第一个声明了变量，第二个为自执行函数，最后一个为表达式，其余的为函数声明式，接下来就需要在各个部分具体发生了什么。</p>
<p>在开头加入debugger;然后在浏览器中调试，首先直接运行自执行函数(第一个表达式)，</p>
<p>我们发现,在第一行直接定义了一个数组，接着是一个自执行函数，传入的参数有两个，第一个为之前的数组，第二个为一个字节码的数字，接着我们发现在里面又定义了一个函数，内含对传入的数组的push,shift操作，通过反复调用该函数达到将数组顺序改变的目的。</p>
<pre><code class="javascript">[&#39;Hello World!&#39;, &#39;log&#39;]
</code></pre>
<p>在进行顺序改变后，数组就变成了上述的形式，紧接着定义了两个函数，最后执行hi()函数，在hi函数中，我们发现它调用了之前定义的_0xae0这个函数，传入了一个字符串，接着跟进 _0xae0a函数中，我们发现它首先是对传入的字符进行了一个运算操作，得到了1，然后就用得到的数去访问之前声明的数组，然后将该值作为返回值，最后 _0xae0a(‘0x1’)就变成了数组中的一个值，最后就运行了这条语句，输出了结果。</p>
<blockquote>
<p>总结：上述主要进行了4部分</p>
<p>1.声明了一个大数组</p>
<p>2.对大数组的顺序进行了改变</p>
<p>3.定义了一个函数，用于取得大数组中的数</p>
<p>4.输出结果</p>
<p>在4中需要调用3才能拿到结果，我们通常把4成为加密函数，3称为解密函数。</p>
</blockquote>
<pre><code class="flow">startID=&gt;start: 声明大数组
operation1=&gt;operation: 数组位置偏移
operation2=&gt;operation: 解密函数
endID=&gt;end: 函数入口


startID-&gt;operation1-&gt;operation2-&gt;endID
operation2-&gt;endID
</code></pre>
<p>在第一个执行函数中，我们发现其传入了两个参数，第一个参数刚好对应的是第二块内容(也就是第一个函数声明)，第二个参数为一个字节码的数字，可不管。在函数内部，首先声明了两个变量，分别调用第一个函数和第三个函数，调用第一个函数的返回值是一个数组，然后在while循环中通过第三个函数不断取数组中的值进行一个计算，接着在进行一个跳出判断，在此之间不断的对数组进行操作(顺序改变).</p>
<p>即第一个自执行函数和第一个函数、第三个函数为一个整体，最终会得到改变了执行顺序的数组，同时将数组写入内存中。</p>
<p>接下来分析最后一个函数和第二个函数体，发现，最后一个函数是直接调用第二个函数体的，而且其函数名与未混淆前的一样为hi().</p>
<p>在hi中又重新调用了第三个函数，取出了其中的参数，然后对混淆进行了解除，最终达到了解除混淆的目的。</p>
<h4 id="AST解OB混淆-lowlevel"><a href="#AST解OB混淆-lowlevel" class="headerlink" title="AST解OB混淆(lowlevel)"></a>AST解OB混淆(lowlevel)</h4><p>还是以上述为例,在此我们采用了lowlevel的加密，首先还是对AST树进行分析。</p>
<pre><code class="javascript">(function (_0x4becbb, _0x142d2c) &#123;
    var _0x4e95f5 = _0xcf3d,
    _0x5cece4 = _0x4becbb();
    while (!![]) &#123;
        try &#123;
            var _0xada9ef = -parseInt(_0x4e95f5(0x1be)) / 0x1 + parseInt(_0x4e95f5(0x1bc)) / 0x2 * (parseInt(_0x4e95f5(0x1bb)) / 0x3) + -parseInt(_0x4e95f5(0x1d2)) / 0x4 * (-parseInt(_0x4e95f5(0x1ca)) / 0x5) + -parseInt(_0x4e95f5(0x1c7)) / 0x6 * (parseInt(_0x4e95f5(0x1c5)) / 0x7) + parseInt(_0x4e95f5(0x1cb)) / 0x8 * (-parseInt(_0x4e95f5(0x1d1)) / 0x9) + -parseInt(_0x4e95f5(0x1d3)) / 0xa + parseInt(_0x4e95f5(0x1d4)) / 0xb;
            if (_0xada9ef === _0x142d2c)
                break;
            else
                _0x5cece4[&#39;push&#39;](_0x5cece4[&#39;shift&#39;]());
        &#125; catch (_0x52b941) &#123;
            _0x5cece4[&#39;push&#39;](_0x5cece4[&#39;shift&#39;]());
        &#125;
    &#125;
&#125;
    (_0x3b5e, 0x373f7));
function _0x3b5e() &#123;
    var _0x3cd390 = [&#39;1386052gLrmrQ&#39;, &#39;456540taaToI&#39;, &#39;2342241LghZeo&#39;, &#39;exception&#39;, &#39;log&#39;, &#39;info&#39;, &#39;45411uGtYTE&#39;, &#39;2wZNffB&#39;, &#39;__proto__&#39;, &#39;172005fARfwU&#39;, &#39;warn&#39;, &#39;return\x20(function()\x20&#39;, &#39;(((.+)+)+)+$&#39;, &#39;apply&#39;, &#39;console&#39;, &#39;search&#39;, &#39;7ehYmcm&#39;, &#39;bind&#39;, &#39;556752jyeSlY&#39;, &#39;&#123;&#125;.constructor(\x22return\x20this\x22)(\x20)&#39;, &#39;trace&#39;, &#39;5zuIaAZ&#39;, &#39;184OzUZAg&#39;, &#39;toString&#39;, &#39;prototype&#39;, &#39;constructor&#39;, &#39;error&#39;, &#39;Hello\x20World!&#39;, &#39;14805EviJWK&#39;];
    _0x3b5e = function () &#123;
        return _0x3cd390;
    &#125;;
    return _0x3b5e();
&#125;
function hi() &#123;
    debugger;
    var _0x12b47a = _0xcf3d,
    _0xbdadaf = function () &#123;
        var _0x22d85c = !![];
        return function (_0x403758, _0x1a9953) &#123;
            var _0x48963d = _0x22d85c ? function () &#123;var _0x52f5f2 = _0xcf3d;if (_0x1a9953) &#123;var _0x1c3993 = _0x1a9953[_0x52f5f2(0x1c2)](_0x403758, arguments);return _0x1a9953 = null,_0x1c3993;&#125;&#125;
             : function () &#123;&#125;;
            return _0x22d85c = ![],
            _0x48963d;
        &#125;;
    &#125;
    (),
    _0x5c0371 = _0xbdadaf(this, function () &#123;
        var _0x36e602 = _0xcf3d;
        return _0x5c0371[&#39;toString&#39;]()[_0x36e602(0x1c4)](_0x36e602(0x1c1))[&#39;toString&#39;]()[_0x36e602(0x1ce)](_0x5c0371)[_0x36e602(0x1c4)](_0x36e602(0x1c1));
    &#125;);
    _0x5c0371();
    var _0xa991eb = function () &#123;
        var _0x9d0201 = !![];
        return function (_0x35b283, _0x1e4ff) &#123;
            var _0x5b9df8 = _0x9d0201 ? function () &#123;
                var _0x4d958a = _0xcf3d;
                if (_0x1e4ff) &#123;
                    var _0x34974c = _0x1e4ff[_0x4d958a(0x1c2)](_0x35b283, arguments);
                    return _0x1e4ff = null,
                    _0x34974c;
                &#125;
            &#125;
             : function () &#123;&#125;;
            return _0x9d0201 = ![],
            _0x5b9df8;
        &#125;;
    &#125;
    (),
    _0x46ef64 = _0xa991eb(this, function () &#123;
        var _0x442076 = _0xcf3d,
        _0x15972f = function () &#123;
            var _0xa6d883 = _0xcf3d,
            _0x5ee4a3;
            try &#123;
                _0x5ee4a3 = Function(_0xa6d883(0x1c0) + _0xa6d883(0x1c8) + &#39;);&#39;)();
            &#125; catch (_0x37267b) &#123;
                _0x5ee4a3 = window;
            &#125;
            return _0x5ee4a3;
        &#125;,
        _0x52d182 = _0x15972f(),
        _0xb55846 = _0x52d182[_0x442076(0x1c3)] = _0x52d182[_0x442076(0x1c3)] || &#123;&#125;,
        _0x503491 = [_0x442076(0x1b9), _0x442076(0x1bf), _0x442076(0x1ba), _0x442076(0x1cf), _0x442076(0x1b8), &#39;table&#39;, _0x442076(0x1c9)];
        for (var _0x2e6262 = 0x0; _0x2e6262 &lt; _0x503491[&#39;length&#39;]; _0x2e6262++) &#123;
            var _0xade831 = _0xa991eb[_0x442076(0x1ce)][_0x442076(0x1cd)][_0x442076(0x1c6)](_0xa991eb),
            _0x202fb0 = _0x503491[_0x2e6262],
            _0x33f2a4 = _0xb55846[_0x202fb0] || _0xade831;
            _0xade831[_0x442076(0x1bd)] = _0xa991eb[_0x442076(0x1c6)](_0xa991eb),
            _0xade831[_0x442076(0x1cc)] = _0x33f2a4[_0x442076(0x1cc)][_0x442076(0x1c6)](_0x33f2a4),
            _0xb55846[_0x202fb0] = _0xade831;
        &#125;
    &#125;);
    _0x46ef64();
    console[_0x12b47a(0x1b9)](_0x12b47a(0x1d0));
&#125;
function _0xcf3d(_0x24ba4c, _0x435eb9) &#123;
    var _0x3efe0d = _0x3b5e();
    return _0xcf3d = function (_0x2feccf, _0x4d6d2b) &#123;
        _0x2feccf = _0x2feccf - 0x1b8;
        var _0x33ef9c = _0x3efe0d[_0x2feccf];
        return _0x33ef9c;
    &#125;,
    _0xcf3d(_0x24ba4c, _0x435eb9);
&#125;
hi();
</code></pre>
<ol>
<li><p>ExpressionStatement</p>
</li>
<li><p>FunctionDeclaration</p>
</li>
<li><p>FunctionDeclaration</p>
</li>
<li><p>FunctionDeclaration</p>
</li>
<li><p>ExpressionStatement</p>
</li>
</ol>
<p>对比默认级的ob我们可以发现，在第一个部分，虽然这里变成了3个函数声明式，但是其实在第二个函数声明式中，还是包含了创建数组这一操作，在自执行函数中依旧包含了数组移位的操作。从执行流程来看，上述分别对应，数组移位，声明数组，加密函数，解密函数，调用函数。</p>
<p>同时，相对之前的Ob来看，这里对数字进行了混淆操作，为了增加代码的可读性，我们先试着对其进行一个数字解混淆的操作。</p>
<pre><code class="javascript">(function (_0x4becbb, _0x142d2c) &#123;
  var _0x4e95f5 = _0xcf3d,
      _0x5cece4 = _0x4becbb();

  while (!![]) &#123;
    try &#123;
      var _0xada9ef = -parseInt(_0x4e95f5(446)) / 1 + parseInt(_0x4e95f5(444)) / 2 * (parseInt(_0x4e95f5(443)) / 3) + -parseInt(_0x4e95f5(466)) / 4 * (-parseInt(_0x4e95f5(458)) / 5) + -parseInt(_0x4e95f5(455)) / 6 * (parseInt(_0x4e95f5(453)) / 7) + parseInt(_0x4e95f5(459)) / 8 * (-parseInt(_0x4e95f5(465)) / 9) + -parseInt(_0x4e95f5(467)) / 10 + parseInt(_0x4e95f5(468)) / 11;

      if (_0xada9ef === _0x142d2c) break;else _0x5cece4[&quot;push&quot;](_0x5cece4[&quot;shift&quot;]());
    &#125; catch (_0x52b941) &#123;
      _0x5cece4[&quot;push&quot;](_0x5cece4[&quot;shift&quot;]());
    &#125;
  &#125;
&#125;)(_0x3b5e, 226295);

function _0x3b5e() &#123;
  var _0x3cd390 = [&quot;1386052gLrmrQ&quot;, &quot;456540taaToI&quot;, &quot;2342241LghZeo&quot;, &quot;exception&quot;, &quot;log&quot;, &quot;info&quot;, &quot;45411uGtYTE&quot;, &quot;2wZNffB&quot;, &quot;__proto__&quot;, &quot;172005fARfwU&quot;, &quot;warn&quot;, &quot;return (function() &quot;, &quot;(((.+)+)+)+$&quot;, &quot;apply&quot;, &quot;console&quot;, &quot;search&quot;, &quot;7ehYmcm&quot;, &quot;bind&quot;, &quot;556752jyeSlY&quot;, &quot;&#123;&#125;.constructor(\&quot;return this\&quot;)( )&quot;, &quot;trace&quot;, &quot;5zuIaAZ&quot;, &quot;184OzUZAg&quot;, &quot;toString&quot;, &quot;prototype&quot;, &quot;constructor&quot;, &quot;error&quot;, &quot;Hello World!&quot;, &quot;14805EviJWK&quot;];

  _0x3b5e = function () &#123;
    return _0x3cd390;
  &#125;;

  return _0x3b5e();
&#125;
function _0xcf3d(_0x24ba4c, _0x435eb9) &#123;
  var _0x3efe0d = _0x3b5e();

  return _0xcf3d = function (_0x2feccf, _0x4d6d2b) &#123;
    _0x2feccf = _0x2feccf - 440;
    var _0x33ef9c = _0x3efe0d[_0x2feccf];
    return _0x33ef9c;
  &#125;, _0xcf3d(_0x24ba4c, _0x435eb9);
&#125;

function hi() &#123;
  var _0x12b47a = _0xcf3d,
      _0xbdadaf = function () &#123;
    var _0x22d85c = !![];

    return function (_0x403758, _0x1a9953) &#123;
      var _0x48963d = _0x22d85c ? function () &#123;
        var _0x52f5f2 = _0xcf3d;

        if (_0x1a9953) &#123;
          var _0x1c3993 = _0x1a9953[_0x52f5f2(450)](_0x403758, arguments);

          return _0x1a9953 = null, _0x1c3993;
        &#125;
      &#125; : function () &#123;&#125;;

      return _0x22d85c = ![], _0x48963d;
    &#125;;
  &#125;(),
      _0x5c0371 = _0xbdadaf(this, function () &#123;
    var _0x36e602 = _0xcf3d;
    return _0x5c0371[&quot;toString&quot;]()[_0x36e602(452)](_0x36e602(449))[&quot;toString&quot;]()[_0x36e602(462)](_0x5c0371)[_0x36e602(452)](_0x36e602(449));
  &#125;);

  _0x5c0371();

  var _0xa991eb = function () &#123;
    var _0x9d0201 = !![];

    return function (_0x35b283, _0x1e4ff) &#123;
      var _0x5b9df8 = _0x9d0201 ? function () &#123;var _0x4d958a = _0xcf3d;if (_0x1e4ff) &#123;var _0x34974c = _0x1e4ff[_0x4d958a(450)](_0x35b283, arguments);return _0x1e4ff = null, _0x34974c;&#125;&#125; : function () &#123;&#125;;return _0x9d0201 = ![], _0x5b9df8;&#125;;&#125;(),
      _0x46ef64 = _0xa991eb(this, function () &#123;
    var _0x442076 = _0xcf3d,
        _0x15972f = function () &#123;
      var _0xa6d883 = _0xcf3d,
          _0x5ee4a3;

      try &#123;
        _0x5ee4a3 = Function(_0xa6d883(448) + _0xa6d883(456) + &quot;);&quot;)();
      &#125; catch (_0x37267b) &#123;
        _0x5ee4a3 = window;
      &#125;

      return _0x5ee4a3;
    &#125;,
        _0x52d182 = _0x15972f(),
        _0xb55846 = _0x52d182[_0x442076(451)] = _0x52d182[_0x442076(451)] || &#123;&#125;,
        _0x503491 = [_0x442076(441), _0x442076(447), _0x442076(442), _0x442076(463), _0x442076(440), &quot;table&quot;, _0x442076(457)];

    for (var _0x2e6262 = 0; _0x2e6262 &lt; _0x503491[&quot;length&quot;]; _0x2e6262++) &#123;
      var _0xade831 = _0xa991eb[_0x442076(462)][_0x442076(461)][_0x442076(454)](_0xa991eb),
          _0x202fb0 = _0x503491[_0x2e6262],
          _0x33f2a4 = _0xb55846[_0x202fb0] || _0xade831;

      _0xade831[_0x442076(445)] = _0xa991eb[_0x442076(454)](_0xa991eb), _0xade831[_0x442076(460)] = _0x33f2a4[_0x442076(460)][_0x442076(454)](_0x33f2a4), _0xb55846[_0x202fb0] = _0xade831;
    &#125;
  &#125;);
  _0x46ef64();
  console[_0x12b47a(441)](_0x12b47a(464));
&#125;

hi();
</code></pre>
<p>这里的数组移位和上述的还是有所不同的，这里是不断对函数里面的数组进行移位操作，所以在解密过程中，还需要从声明数组的函数中取出数组。</p>
<p>接着我们就需要分析解密函数和加密函数。</p>
<p>解密函数看到很直白，就是传入参数，将参数值进行一个减法操作，然后取出数组下标为该参数的值。</p>
<p>接下来就看加密函数，我们很轻易的就能从最后一行中发现，该处应该是最后打印值的地方，那么上述一些步骤到底在做些什么呢？</p>
<p>我们发现，其实该处只是调用了数组，我们只需要找到数组的声明位置即可。</p>
<p>通过调试，可以发现，最后一句才是我们要的结果，通过解密函数可以直接打印出结果。</p>
<p>如果混淆后的代码较短，我们就可以很轻易的分析出实际的逻辑。</p>
<h4 id="实战-某比赛第二题"><a href="#实战-某比赛第二题" class="headerlink" title="实战(某比赛第二题)"></a>实战(某比赛第二题)</h4><p>将js代码放入babel网站解析，发现明显的分为四块：</p>
<ol>
<li>VariableDeclaration</li>
<li>ExpressionStatement</li>
<li>VariableDeclaration</li>
<li>ExpressionStatement</li>
</ol>
<p>在经过上述分析后，我们可以把Ob大至抽象为如下四个阶段：</p>
<ol>
<li>定义大数组</li>
<li>数组移位</li>
<li>定义解密函数</li>
<li>函数入口</li>
</ol>
<blockquote>
<p>补充：AST还原主要是为了让干扰项尽可能减少，让代码逻辑尽可能的变清晰，本身并不能达到秒杀的结果。</p>
</blockquote>
<h5 id="step1：解密函数内存写入"><a href="#step1：解密函数内存写入" class="headerlink" title="step1：解密函数内存写入"></a>step1：解密函数内存写入</h5><p>函数入口中的内容大部分都是由解密函数生成的，那么我们首先要做的就是将解密函数写入内存中。</p>
<pre><code class="javascript">//定义解密数组名称,与原函数对其
let descrypt_arr_name = &#39;$b&#39;
let descrypt_strfun_js = &#39;&#39;;
for(let i=0;i&lt;=2;i++)&#123;
    //加入代码
    descrypt_strfun_js += generator(ast_code.program.body[i], &#123;compact:true&#125;).code
    delete ast_code.program.body[i]
&#125;
// 写入内存
eval(descrypt_strfun_js);
//此时就可以打印出结果
console.log($b);
</code></pre>
<h5 id="step2：解密函数还原"><a href="#step2：解密函数还原" class="headerlink" title="step2：解密函数还原"></a>step2：解密函数还原</h5><p>在内存中包含解数组后，我们就只需要将每一个调用解密数组的地方替换即可，不过在此之前还需要对整体的ASCII码类型进行还原，同时若是数组调用类型为a[‘1’+’2’]这种形式也需要先还原成a[‘12’]这种形式。</p>
<pre><code class="javascript">const ASCII_visitor = &#123;
    //对ASCII码进行还原
    StringLiteral(path) &#123;
        if(path.node.extra)&#123;
            path.node.extra = undefined;
        &#125;
    &#125;,
    NumericLiteral(path) &#123;
        if(path.node.extra)&#123;
            path.node.extra = undefined;
        &#125;
    &#125;,
    BinaryExpression(path)&#123;
        //二项式计算，都为字符类型，则直接相加
        let left = path.node.left;
        let right = path.node.right;
        let operator = path.node.operator;
        //字符串相加
        if(types.isStringLiteral(left) &amp;&amp; types.isStringLiteral(right) &amp;&amp; operator === &#39;+&#39;)&#123;
            // path.evaluate()为节点计算，自动相加里面的value,得出三个参数：confident:true为可相加,deopt:暂时不清楚,value:加后的值
            const &#123;value&#125; = path.evaluate();
            path.replaceInline(types.valueToNode(value));
        &#125;
    &#125;
&#125;;

traverse(ast_code, ASCII_visitor);

arr_change_visitor = &#123;
    //解密数组还原
    CallExpression(path) &#123;
        // 调用数组名字与数组函数相同
        if(path.node.callee.name  === descrypt_arr_name &amp;&amp; path.node.arguments.length ===2)&#123;
            path.replaceInline(types.valueToNode(eval(path.toString())));
        &#125;
    &#125;
&#125;

traverse(ast_code, arr_change_visitor);
</code></pre>
<h5 id="step3：对象置换与写入"><a href="#step3：对象置换与写入" class="headerlink" title="step3：对象置换与写入"></a>step3：对象置换与写入</h5><p>接下来就发现，存在对象声明以及对象写入,以如下形式表现：</p>
<pre><code class="javascript">var a = &#123;&#125;;
a[&#39;1&#39;] = &#39;1&#39; + &#39;2&#39; + &#39;3&#39;;
a[&#39;213&#39; + &#39;231&#39;] = function(a,b)&#123;
    return a + b
&#125;;
var b = a;
</code></pre>
<p>这里沿用上述思想，也将对象写入内存中，然后直接替换，由于’1’+’2’+‘3类似这种需要采用上述ASCII_visitor进一步还原，是为了防</p>
<p>存入内存后，部分函数无法还原。同时，在此基础上还需要加上变量替换、无效代码去除的操作。</p>
<pre><code class="javascript">//变量替换
fun_use_visitor = &#123;
    VariableDeclarator(path)&#123;
        const func_name = path.node.id.name;
        let binding = path.scope.getBinding(func_name);
        if(!binding)&#123;return&#125;;
        binding.scope.traverse(binding.scope.block,&#123;
            VariableDeclarator(_path)&#123;
            let &#123;id,init&#125; = _path.node;
            if (!types.isIdentifier(init,&#123;name:func_name&#125;)) return;
            _path.scope.rename(id.name,func_name);
            &#125;
        &#125;)
    &#125;
&#125;;

//无效代码去除
dead_visitor = &#123;
    VariableDeclarator(path) &#123;
        const &#123;id,init&#125; = path.node;
        if(!init)&#123;return&#125;;
        if(id.name === init.name)&#123;
            path.remove();
        &#125;

    &#125;
&#125;;

traverse(ast_code, fun_use_visitor);

for(var i=0;i&lt;=10;i++) &#123;
    traverse(ast_code, ASCII_visitor);
&#125;
// 对象内存写入,y1对应的解密函数的实际值,方便后续观察读写中哪里存在问题
y1 = &#123;&#125;;
memeory_visitor = &#123;
    VariableDeclarator(path) &#123;
        if(path.node.init &amp;&amp; path.node.init.type === &#39;ObjectExpression&#39;)&#123;
        const func_name = path.node.id.name;
        //打印当前变量名称&#39;
        eval(path.toString());
        //对象内存替换,保证内存中的对象键值为node类型、
        for (temp of path.node.init.properties)&#123;
            let key = temp.key.value;
            let value = temp.value;
            eval(func_name)[key] = value;
        &#125;;  
        let binding = path.scope.getBinding(func_name);
        binding.scope.traverse(binding.scope.block, &#123;
            AssignmentExpression(_path) &#123;
                //筛选需要的对象.判断是否为对象类型
                if(_path.node.left.type  !== &#39;MemberExpression&#39; || _path.node.left.object.name !== func_name )&#123;return&#125;;
                 eval(func_name)[_path.node.left.property.value] = _path.node.right;
                 y1[_path.node.left.property.value] = _path.toString();
                _path.remove();
            &#125;
        &#125;),
            path.remove()
&#125;&#125;
&#125;;

// 内部调用对象,将键值对去掉
second_visitor = &#123;
    MemberExpression(path) &#123;
        //对于值为字符类型的进行替换
        cur_name = path.node.object.name;

        if(!global[cur_name])&#123;return&#125;
        // 如果存在内存中
        if(cur_name &amp;&amp; cur_name in global)&#123;
            if(!eval(cur_name)[path.node.property.value])&#123;return&#125;;
            if(eval(cur_name)[path.node.property.value].property &amp;&amp; eval(cur_name)[path.node.property.value].property.type ===&#39;StringLiteral&#39;)&#123;
            //替换节点
            path.replaceInline(types.stringLiteral(eval(cur_name)[path.node.property.value].property.value));
        &#125;else if(eval(cur_name)[path.node.property.value].type === &#39;StringLiteral&#39;)&#123;
                // console.log(eval(cur_name)[path.node.property.value]);
                path.replaceInline(types.stringLiteral(eval(cur_name)[path.node.property.value].value));
            &#125;
        &#125;
    &#125;,
    CallExpression(path)&#123;
        //对值为函数类型的进行替换
        if(path.node.callee.type !== &#39;MemberExpression&#39;)&#123;return&#125;;
        //定义调用对象的名称
        var func_name = path.node.callee.object.name;
        //只调用存在内存中的对象
        if(!global[func_name])&#123;return&#125;;
        if(!eval(func_name)[path.node.callee.property.value])&#123;return;&#125;;
        if(func_name &amp;&amp; func_name in global &amp;&amp; eval(func_name)[path.node.callee.property.value].type === &#39;FunctionExpression&#39;)&#123;
            if(eval(func_name)[path.node.callee.property.value].body.body[0].argument.type === &#39;BinaryExpression&#39;)&#123;
                const operator = eval(func_name)[path.node.callee.property.value].body.body[0].argument.operator;
                // console.log(path.node.arguments[0]);
                path.replaceInline(types.binaryExpression(operator, path.node.arguments[0], path.node.arguments[1]));
            &#125;else if(eval(func_name)[path.node.callee.property.value].body.body[0].argument.type === &#39;CallExpression&#39;)&#123;
                // console.log(eval(func_name)[path.node.callee.property.value].body.body[0].argument.arguments.length);
                if(eval(func_name)[path.node.callee.property.value].body.body[0].argument.arguments.length === 0)&#123;
                    //内存函数替换,形如a()调用转换
                    var temp_func = eval(func_name)[path.node.callee.property.value].body.body[0].argument;
                    temp_func.callee.name = path.node.arguments[0].name;
                    path.replaceInline(eval(func_name)[path.node.callee.property.value].body.body[0].argument);
                    return;
                &#125;;
                if(!eval(func_name)[path.node.callee.property.value].body.body[0].argument.callee.object)&#123;return&#125;;
                const call_name = eval(func_name)[path.node.callee.property.value].body.body[0].argument.callee.object.name;
                if(!call_name)&#123;return&#125;;
                var arr = path.node.arguments;
                var a = arr.filter(function(item)&#123;return item.name != call_name&#125;);
                //对参数进行切片,第一个为对应的函数名,其余的为参数
                path.replaceInline(types.callExpression(eval(func_name)[path.node.callee.property.value].body.body[0].argument.callee, a));

            &#125;
        &#125;
    &#125;
&#125;;

traverse(ast_code, memeory_visitor);
traverse(ast_code, second_visitor);
third_visitor = &#123;
    CallExpression(path)&#123;
        //如果函数对应的部分也为函数调用式
        cur_node = path.node;
        if(!cur_node.callee.object)&#123;return&#125;;
        var func_name = path.node.callee.object.name;
        if(global[func_name])&#123;
            // console.log(eval(func_name)[path.node.callee.property.value]);
        if(!eval(func_name)[path.node.callee.property.value])&#123;return;&#125;;
        if(eval(func_name)[path.node.callee.property.value].body &amp;&amp; eval(func_name)[path.node.callee.property.value].body.body[0].argument.type === &#39;CallExpression&#39;)&#123;
            const arg = cur_node.arguments.slice(1);
            path.replaceInline(types.callExpression(cur_node.arguments[0], arg))
        &#125;
    &#125;&#125;
&#125;;

traverse(ast_code, third_visitor);
traverse(ast_code, dead_visitor);
//可判断对象内存写入是否存在问题。
// console.log(y1);
</code></pre>
<h5 id="step4：扫尾工作"><a href="#step4：扫尾工作" class="headerlink" title="step4：扫尾工作"></a>step4：扫尾工作</h5><p>经过上述步骤，代码已经压缩成了240行，代码(如下)的逻辑已经清晰可见，控制流也不是很复杂，暂时没必要用到还原，其中有个BUG处：</p>
<pre><code class="javascript">(function $c(k) &#123;
  var B = function () &#123;
    var Y = !![];
    return function (Z, a0) &#123;
      var a1 = Y ? function () &#123;
        if (a0) &#123;
          var a2 = a0[&quot;apply&quot;](Z, arguments);
          a0 = null;
          return a2;
        &#125;
      &#125; : function () &#123;&#125;;
      Y = ![];
      return a1;
    &#125;;
  &#125;();

  function C(Y, Z) &#123;
    var a0 = (65535 &amp; Y) + (65535 &amp; Z);
    return (Y &gt;&gt; 16) + (Z &gt;&gt; 16) + (a0 &gt;&gt; 16) &lt;&lt; 16 | 65535 &amp; a0;
  &#125;

  function D(Y, Z) &#123;
    return Y &lt;&lt; Z | Y &gt;&gt;&gt; 32 - Z;
  &#125;

  function E(Y, Z, a0, a1, a2, a3) &#123;
    return C(D(C(C(Z, Y), C(a1, a3)), a2), a0);
  &#125;

  function F(Y, Z, a0, a1, a2, a3, a4) &#123;
    return E(Z &amp; a0 | ~Z &amp; a1, Y, Z, a2, a3, a4);
  &#125;

  function G(Y, Z, a0, a1, a2, a3, a4) &#123;
    return E(Z &amp; a1 | a0 &amp; ~a1, Y, Z, a2, a3, a4);
  &#125;

  function H(Y, Z) &#123;
    let a0 = [99, 111, 110, 115, 111, 108, 101];
    let a1 = &quot;&quot;;

    for (let a2 = 0; a2 &lt; a0[&quot;length&quot;]; a2++) &#123;
      a1 += String[&quot;fromCharCode&quot;](a0[a2]);
    &#125;

    return a1;
  &#125;

  function I(Y, Z, a0, a1, a2, a3, a4) &#123;
    return E(Z ^ a0 ^ a1, Y, Z, a2, a3, a4);
  &#125;

  function J(Y, Z, a0, a1, a2, a3, a4) &#123;
    return E(a0 ^ (Z | ~a1), Y, Z, a2, a3, a4);
  &#125;

  function K(Y, Z) &#123;
    if (Z) &#123;
      return J(Y);
    &#125;

    return H(Y);
  &#125;

  function L(Y, Z) &#123;
    let a0 = &quot;&quot;;

    for (let a1 = 0; a1 &lt; Y[&quot;length&quot;]; a1++) &#123;
      a0 += String[&quot;fromCharCode&quot;](Y[a1]);
    &#125;

    return a0;
  &#125;

  function M(Y, Z) &#123;
    var a0 = &quot;6|1|2|5|0|4|3&quot;[&quot;split&quot;](&quot;|&quot;);
    var a1 = 0;

    while (!![]) &#123;
      switch (a0[a1++]) &#123;
        case &quot;0&quot;:
          qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10];
          continue;

        case &quot;1&quot;:
          var a2 = B(this, function () &#123;
            var a5 = function () &#123;
              var a6 = a5[&quot;constructor&quot;](&quot;ZKLFz&quot;)()[&quot;compile&quot;](&quot;^([^ ]+( +[^ ]+)+)+[^ ]&#125;&quot;);
              return !a6[&quot;test&quot;](a2);
            &#125;;

            return a5();
          &#125;);
          continue;

        case &quot;2&quot;:
          a2();
          continue;

        case &quot;3&quot;:
          try &#123;
            if (global) &#123;
              console[&quot;log&quot;](&quot;\u4EBA\u751F\u82E6\u77ED\uFF0C\u4F55\u5FC5python\uFF1F&quot;);
            &#125; else &#123;
              while (1) &#123;
                console[&quot;log&quot;](&quot;\u4EBA\u751F\u82E6\u77ED\uFF0C\u4F55\u5FC5python\uFF1F&quot;);
                debugger;
              &#125;
            &#125;
          &#125; catch (a5) &#123;
            return navigator[&quot;vendorSub&quot;];
          &#125;

          continue;

        case &quot;4&quot;:
          eval(L(qz));
          continue;

        case &quot;5&quot;:
          K();
          continue;

        case &quot;6&quot;:
          continue;
      &#125;

      break;
    &#125;
  &#125;

  setInterval(M(), 500);

  function N(Y, Z) &#123;
    Y[Z &gt;&gt; 5] |= 128 &lt;&lt; Z % 32, Y[14 + (Z + 64 &gt;&gt;&gt; 9 &lt;&lt; 4)] = Z;

    if (qz) &#123;
      var a0,
          a1,
          a2,
          a3,
          a4,
          a5 = 1732584193,
          a6 = -271733879,
          a7 = -1732584194,
          a8 = 271733878;
    &#125; else &#123;
      var a0,
          a1,
          a2,
          a3,
          a4,
          a5 = 0,
          a6 = -0,
          a7 = -0,
          a8 = 0;
    &#125;

    for (a0 = 0; a0 &lt; Y[&quot;length&quot;]; a0 += 16) a1 = a5, a2 = a6, a3 = a7, a4 = a8, a5 = F(a5, a6, a7, a8, Y[a0], 7, -680876936), a8 = F(a8, a5, a6, a7, Y[a0 + 1], 12, -389564586), a7 = F(a7, a8, a5, a6, Y[a0 + 2], 17, 606105819), a6 = F(a6, a7, a8, a5, Y[a0 + 3], 22, -1044525330), a5 = F(a5, a6, a7, a8, Y[a0 + 4], 7, -176418897), a8 = F(a8, a5, a6, a7, Y[a0 + 5], 12, 1200080426), a7 = F(a7, a8, a5, a6, Y[a0 + 6], 17, -1473231341), a6 = F(a6, a7, a8, a5, Y[a0 + 7], 22, -45705983), a5 = F(a5, a6, a7, a8, Y[a0 + 8], 7, 1770010416), a8 = F(a8, a5, a6, a7, Y[a0 + 9], 12, -1958414417), a7 = F(a7, a8, a5, a6, Y[a0 + 10], 17, -42063), a6 = F(a6, a7, a8, a5, Y[a0 + 11], 22, -1990404162), a5 = F(a5, a6, a7, a8, Y[a0 + 12], 7, 1804603682), a8 = F(a8, a5, a6, a7, Y[a0 + 13], 12, -40341101), a7 = F(a7, a8, a5, a6, Y[a0 + 14], 17, -1502882290), a6 = F(a6, a7, a8, a5, Y[a0 + 15], 22, 1236535329), a5 = G(a5, a6, a7, a8, Y[a0 + 1], 5, -165796510), a8 = G(a8, a5, a6, a7, Y[a0 + 6], 9, -1069501632), a7 = G(a7, a8, a5, a6, Y[a0 + 11], 14, 643717713), a6 = G(a6, a7, a8, a5, Y[a0], 20, -373897302), a5 = G(a5, a6, a7, a8, Y[a0 + 5], 5, -701558691), a8 = G(a8, a5, a6, a7, Y[a0 + 10], 9, 38016083), a7 = G(a7, a8, a5, a6, Y[a0 + 15], 14, -660478335), a6 = G(a6, a7, a8, a5, Y[a0 + 4], 20, -405537848), a5 = G(a5, a6, a7, a8, Y[a0 + 9], 5, 568446438), a8 = G(a8, a5, a6, a7, Y[a0 + 14], 9, -1019803690), a7 = G(a7, a8, a5, a6, Y[a0 + 3], 14, -187363961), a6 = G(a6, a7, a8, a5, Y[a0 + 8], 20, 1163531501), a5 = G(a5, a6, a7, a8, Y[a0 + 13], 5, -1444681467), a8 = G(a8, a5, a6, a7, Y[a0 + 2], 9, -51403784), a7 = G(a7, a8, a5, a6, Y[a0 + 7], 14, 1735328473), a6 = G(a6, a7, a8, a5, Y[a0 + 12], 20, -1926607734), a5 = I(a5, a6, a7, a8, Y[a0 + 5], 4, -378558), a8 = I(a8, a5, a6, a7, Y[a0 + 8], 11, -2022574463), a7 = I(a7, a8, a5, a6, Y[a0 + 11], 16, 1839030562), a6 = I(a6, a7, a8, a5, Y[a0 + 14], 23, -35309556), a5 = I(a5, a6, a7, a8, Y[a0 + 1], 4, -1530992060), a8 = I(a8, a5, a6, a7, Y[a0 + 4], 11, 1272893353), a7 = I(a7, a8, a5, a6, Y[a0 + 7], 16, -155497632), a6 = I(a6, a7, a8, a5, Y[a0 + 10], 23, -1094730640), a5 = I(a5, a6, a7, a8, Y[a0 + 13], 4, 681279174), a8 = I(a8, a5, a6, a7, Y[a0], 11, -358537222), a7 = I(a7, a8, a5, a6, Y[a0 + 3], 16, -722521979), a6 = I(a6, a7, a8, a5, Y[a0 + 6], 23, 76029189), a5 = I(a5, a6, a7, a8, Y[a0 + 9], 4, -640364487), a8 = I(a8, a5, a6, a7, Y[a0 + 12], 11, -421815835), a7 = I(a7, a8, a5, a6, Y[a0 + 15], 16, 530742520), a6 = I(a6, a7, a8, a5, Y[a0 + 2], 23, -995338651), a5 = J(a5, a6, a7, a8, Y[a0], 6, -198630844), a8 = J(a8, a5, a6, a7, Y[a0 + 7], 10, 1126891415), a7 = J(a7, a8, a5, a6, Y[a0 + 14], 15, -1416354905), a6 = J(a6, a7, a8, a5, Y[a0 + 5], 21, -57434055), a5 = J(a5, a6, a7, a8, Y[a0 + 12], 6, 1700485571), a8 = J(a8, a5, a6, a7, Y[a0 + 3], 10, -1894986606), a7 = J(a7, a8, a5, a6, Y[a0 + 10], 15, -1051523), a6 = J(a6, a7, a8, a5, Y[a0 + 1], 21, -2054922799), a5 = J(a5, a6, a7, a8, Y[a0 + 8], 6, 1873313359), a8 = J(a8, a5, a6, a7, Y[a0 + 15], 10, -30611744), a7 = J(a7, a8, a5, a6, Y[a0 + 6], 15, -1560198380), a6 = J(a6, a7, a8, a5, Y[a0 + 13], 21, 1309151649), a5 = J(a5, a6, a7, a8, Y[a0 + 4], 6, -145523070), a8 = J(a8, a5, a6, a7, Y[a0 + 11], 10, -1120210379), a7 = J(a7, a8, a5, a6, Y[a0 + 2], 15, 718787259), a6 = J(a6, a7, a8, a5, Y[a0 + 9], 21, -343485441), a5 = C(a5, a1), a6 = C(a6, a2), a7 = C(a7, a3), a8 = C(a8, a4);

    return [a5, a6, a7, a8];
  &#125;

  function O(Y) &#123;
    var Z,
        a0 = &quot;&quot;,
        a1 = 32 * Y[&quot;length&quot;];

    for (Z = 0; Z &lt; a1; Z += 8) a0 += String[&quot;fromCharCode&quot;](Y[Z &gt;&gt; 5] &gt;&gt;&gt; Z % 32 &amp; 255);

    return a0;
  &#125;

  function P(Y) &#123;
    var Z = &quot;0|1|4|2|3&quot;[&quot;split&quot;](&quot;|&quot;);
    var a0 = 0;

    while (!![]) &#123;
      switch (Z[a0++]) &#123;
        case &quot;0&quot;:
          var a1,
              a2 = [];
          continue;

        case &quot;1&quot;:
          for (a2[(Y[&quot;length&quot;] &gt;&gt; 2) - 1] = void 0, a1 = 0; a1 &lt; a2[&quot;length&quot;]; a1 += 1) a2[a1] = 0;

          continue;

        case &quot;2&quot;:
          for (a1 = 0; a1 &lt; a3; a1 += 8) a2[a1 &gt;&gt; 5] |= (255 &amp; Y[&quot;charCodeAt&quot;](a1 / 8)) &lt;&lt; a1 % 32;

          continue;

        case &quot;3&quot;:
          return a2;

        case &quot;4&quot;:
          var a3 = 8 * Y[&quot;length&quot;];
          continue;
      &#125;

      break;
    &#125;
  &#125;

  function Q(Y) &#123;
    return O(N(P(Y), 8 * Y[&quot;length&quot;]));
  &#125;

  function R(Y) &#123;
    var Z,
        a0,
        a1 = &quot;0123456789abcdef&quot;,
        a2 = &quot;&quot;;

    for (a0 = 0; a0 &lt; Y[&quot;length&quot;]; a0 += 1) Z = Y[&quot;charCodeAt&quot;](a0), a2 += a1[&quot;charAt&quot;](Z &gt;&gt;&gt; 4 &amp; 15) + a1[&quot;charAt&quot;](15 &amp; Z);

    return a2;
  &#125;

  function S(Y) &#123;
    return unescape(encodeURIComponent(Y));
  &#125;

  function T(Y) &#123;
    return Q(S(Y));
  &#125;

  function U(Y) &#123;
    return R(T(Y));
  &#125;

  function V(Y, Z, a0) &#123;
    M();
    return Z ? a0 ? H(Z, Y) : y(Z, Y) : a0 ? T(Y) : U(Y);
  &#125;

  function W(Y, Z) &#123;
    document[&quot;cookie&quot;] = &quot;m&quot; + M() + &quot;=&quot; + V(Y) + &quot;|&quot; + Y + &quot;; path=/&quot;;
    location[&quot;reload&quot;]();
  &#125;

  function X(Y, Z) &#123;
    return Date[&quot;parse&quot;](new Date());
  &#125;

  W(X());
&#125;)();
</code></pre>
<blockquote>
<p>PS:运行会报ZKLFz处的错误，可能是由于对’y[“ZKLFz”] &#x3D; “return &#x2F;\“ + this + \“&#x2F;“‘这个还原的时候出现了一点小问题，通过分析该处代码，很明显这里是在对什么东西进行一个检测，然后返回的一个是boolean型变量,将代码修改即可结束。</p>
</blockquote>
<p>最后将其中的环境检测补掉，最后即破解结束。</p>
<pre><code class="javascript">//修改后完整代码如下
//提取hook一个console.log;
console_hk = console.log;
var B = function () &#123;
    var Y = !![];
    return function (Z, a0) &#123;
        var a1 = Y ? function () &#123;
            if (a0) &#123;
                var a2 = a0[&quot;apply&quot;](Z, arguments);
                a0 = null;
                return a2;
            &#125;
        &#125; : function () &#123;
        &#125;;
        Y = ![];
        return a1;
    &#125;;
&#125;();

function C(Y, Z) &#123;
    var a0 = (65535 &amp; Y) + (65535 &amp; Z);
    return (Y &gt;&gt; 16) + (Z &gt;&gt; 16) + (a0 &gt;&gt; 16) &lt;&lt; 16 | 65535 &amp; a0;
&#125;

function D(Y, Z) &#123;
    return Y &lt;&lt; Z | Y &gt;&gt;&gt; 32 - Z;
&#125;

function E(Y, Z, a0, a1, a2, a3) &#123;
    return C(D(C(C(Z, Y), C(a1, a3)), a2), a0);
&#125;

function F(Y, Z, a0, a1, a2, a3, a4) &#123;
    return E(Z &amp; a0 | ~Z &amp; a1, Y, Z, a2, a3, a4);
&#125;

function G(Y, Z, a0, a1, a2, a3, a4) &#123;
    return E(Z &amp; a1 | a0 &amp; ~a1, Y, Z, a2, a3, a4);
&#125;

function H(Y, Z) &#123;
    let a0 = [99, 111, 110, 115, 111, 108, 101];
    let a1 = &quot;&quot;;

    for (let a2 = 0; a2 &lt; a0[&quot;length&quot;]; a2++) &#123;
        a1 += String[&quot;fromCharCode&quot;](a0[a2]);
    &#125;

    return a1;
&#125;

function I(Y, Z, a0, a1, a2, a3, a4) &#123;
    return E(Z ^ a0 ^ a1, Y, Z, a2, a3, a4);
&#125;

function J(Y, Z, a0, a1, a2, a3, a4) &#123;
    return E(a0 ^ (Z | ~a1), Y, Z, a2, a3, a4);
&#125;

function K(Y, Z) &#123;
    if (Z) &#123;
        return J(Y);
    &#125;

    return H(Y);
&#125;

function L(Y, Z) &#123;
    let a0 = &quot;&quot;;

    for (let a1 = 0; a1 &lt; Y[&quot;length&quot;]; a1++) &#123;
        a0 += String[&quot;fromCharCode&quot;](Y[a1]);
    &#125;

    return a0;
&#125;

function M(Y, Z) &#123;
    var a0 = &quot;6|1|2|5|0|4|3&quot;[&quot;split&quot;](&quot;|&quot;);
    var a1 = 0;

    while (!![]) &#123;
        switch (a0[a1++]) &#123;
            case &quot;0&quot;:
                qz = [10, 99, 111, 110, 115, 111, 108, 101, 32, 61, 32, 110, 101, 119, 32, 79, 98, 106, 101, 99, 116, 40, 41, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 32, 61, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 40, 115, 41, 32, 123, 10, 32, 32, 32, 32, 119, 104, 105, 108, 101, 32, 40, 49, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 40, 105, 61, 48, 59, 105, 60, 49, 49, 48, 48, 48, 48, 48, 59, 105, 43, 43, 41, 123, 10, 32, 32, 32, 32, 32, 32, 32, 32, 104, 105, 115, 116, 111, 114, 121, 46, 112, 117, 115, 104, 83, 116, 97, 116, 101, 40, 48, 44, 48, 44, 105, 41, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125, 10, 32, 32, 32, 32, 125, 10, 10, 125, 10, 99, 111, 110, 115, 111, 108, 101, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 91, 111, 98, 106, 101, 99, 116, 32, 79, 98, 106, 101, 99, 116, 93, 39, 10, 99, 111, 110, 115, 111, 108, 101, 46, 108, 111, 103, 46, 116, 111, 83, 116, 114, 105, 110, 103, 32, 61, 32, 39, 402, 32, 116, 111, 83, 116, 114, 105, 110, 103, 40, 41, 32, 123, 32, 91, 110, 97, 116, 105, 118, 101, 32, 99, 111, 100, 101, 93, 32, 125, 39, 10];
                continue;

            case &quot;1&quot;:
                var a2 = B(this, function () &#123;
                    var a5 = function () &#123;
                        //var a6 = a5[&quot;constructor&quot;](&quot;ZKLFz&quot;)()[&quot;compile&quot;](&quot;^([^ ]+( +[^ ]+)+)+[^ ]&#125;&quot;);
                        //return !a6[&quot;test&quot;](a2);浏览器里为true直接替换
                        return true;
                    &#125;;

                    return a5();
                &#125;);
                continue;

            case &quot;2&quot;:
                a2();
                continue;

            case &quot;3&quot;:
                //去掉无线debugger;
                // try &#123;
                //这里对node的global进行了一个检测
                //     if (global) &#123;
                //         console[&quot;log&quot;](&quot;\u4EBA\u751F\u82E6\u77ED\uFF0C\u4F55\u5FC5python\uFF1F&quot;);
                //     &#125; else &#123;
                //         while (1) &#123;
                //             console[&quot;log&quot;](&quot;\u4EBA\u751F\u82E6\u77ED\uFF0C\u4F55\u5FC5python\uFF1F&quot;);
                //             debugger;
                //         &#125;
                //     &#125;
                // &#125; catch (a5) &#123;
                //     return navigator[&quot;vendorSub&quot;];
                // &#125;
                // navigator[&quot;vendorSub&quot;]这个在浏览器里面就为&#39;&#39;所以直接返回这个。
                    return &#39;&#39;
                continue;

            case &quot;4&quot;:
                eval(L(qz));
                continue;

            case &quot;5&quot;:
                K();
                continue;

            case &quot;6&quot;:
                var a3 = a3;
                continue;
        &#125;

        break;
    &#125;
&#125;

// setInterval(M(), 500);

function N(Y, Z) &#123;
    Y[Z &gt;&gt; 5] |= 128 &lt;&lt; Z % 32, Y[14 + (Z + 64 &gt;&gt;&gt; 9 &lt;&lt; 4)] = Z;

    if (qz) &#123;
        var a0,
            a1,
            a2,
            a3,
            a4,
            a5 = 1732584193,
            a6 = -271733879,
            a7 = -1732584194,
            a8 = 271733878;
    &#125; else &#123;
        var a0,
            a1,
            a2,
            a3,
            a4,
            a5 = 0,
            a6 = -0,
            a7 = -0,
            a8 = 0;
    &#125;

    for (a0 = 0; a0 &lt; Y[&quot;length&quot;]; a0 += 16) a1 = a5, a2 = a6, a3 = a7, a4 = a8, a5 = F(a5, a6, a7, a8, Y[a0], 7, -680876936), a8 = F(a8, a5, a6, a7, Y[a0 + 1], 12, -389564586), a7 = F(a7, a8, a5, a6, Y[a0 + 2], 17, 606105819), a6 = F(a6, a7, a8, a5, Y[a0 + 3], 22, -1044525330), a5 = F(a5, a6, a7, a8, Y[a0 + 4], 7, -176418897), a8 = F(a8, a5, a6, a7, Y[a0 + 5], 12, 1200080426), a7 = F(a7, a8, a5, a6, Y[a0 + 6], 17, -1473231341), a6 = F(a6, a7, a8, a5, Y[a0 + 7], 22, -45705983), a5 = F(a5, a6, a7, a8, Y[a0 + 8], 7, 1770010416), a8 = F(a8, a5, a6, a7, Y[a0 + 9], 12, -1958414417), a7 = F(a7, a8, a5, a6, Y[a0 + 10], 17, -42063), a6 = F(a6, a7, a8, a5, Y[a0 + 11], 22, -1990404162), a5 = F(a5, a6, a7, a8, Y[a0 + 12], 7, 1804603682), a8 = F(a8, a5, a6, a7, Y[a0 + 13], 12, -40341101), a7 = F(a7, a8, a5, a6, Y[a0 + 14], 17, -1502882290), a6 = F(a6, a7, a8, a5, Y[a0 + 15], 22, 1236535329), a5 = G(a5, a6, a7, a8, Y[a0 + 1], 5, -165796510), a8 = G(a8, a5, a6, a7, Y[a0 + 6], 9, -1069501632), a7 = G(a7, a8, a5, a6, Y[a0 + 11], 14, 643717713), a6 = G(a6, a7, a8, a5, Y[a0], 20, -373897302), a5 = G(a5, a6, a7, a8, Y[a0 + 5], 5, -701558691), a8 = G(a8, a5, a6, a7, Y[a0 + 10], 9, 38016083), a7 = G(a7, a8, a5, a6, Y[a0 + 15], 14, -660478335), a6 = G(a6, a7, a8, a5, Y[a0 + 4], 20, -405537848), a5 = G(a5, a6, a7, a8, Y[a0 + 9], 5, 568446438), a8 = G(a8, a5, a6, a7, Y[a0 + 14], 9, -1019803690), a7 = G(a7, a8, a5, a6, Y[a0 + 3], 14, -187363961), a6 = G(a6, a7, a8, a5, Y[a0 + 8], 20, 1163531501), a5 = G(a5, a6, a7, a8, Y[a0 + 13], 5, -1444681467), a8 = G(a8, a5, a6, a7, Y[a0 + 2], 9, -51403784), a7 = G(a7, a8, a5, a6, Y[a0 + 7], 14, 1735328473), a6 = G(a6, a7, a8, a5, Y[a0 + 12], 20, -1926607734), a5 = I(a5, a6, a7, a8, Y[a0 + 5], 4, -378558), a8 = I(a8, a5, a6, a7, Y[a0 + 8], 11, -2022574463), a7 = I(a7, a8, a5, a6, Y[a0 + 11], 16, 1839030562), a6 = I(a6, a7, a8, a5, Y[a0 + 14], 23, -35309556), a5 = I(a5, a6, a7, a8, Y[a0 + 1], 4, -1530992060), a8 = I(a8, a5, a6, a7, Y[a0 + 4], 11, 1272893353), a7 = I(a7, a8, a5, a6, Y[a0 + 7], 16, -155497632), a6 = I(a6, a7, a8, a5, Y[a0 + 10], 23, -1094730640), a5 = I(a5, a6, a7, a8, Y[a0 + 13], 4, 681279174), a8 = I(a8, a5, a6, a7, Y[a0], 11, -358537222), a7 = I(a7, a8, a5, a6, Y[a0 + 3], 16, -722521979), a6 = I(a6, a7, a8, a5, Y[a0 + 6], 23, 76029189), a5 = I(a5, a6, a7, a8, Y[a0 + 9], 4, -640364487), a8 = I(a8, a5, a6, a7, Y[a0 + 12], 11, -421815835), a7 = I(a7, a8, a5, a6, Y[a0 + 15], 16, 530742520), a6 = I(a6, a7, a8, a5, Y[a0 + 2], 23, -995338651), a5 = J(a5, a6, a7, a8, Y[a0], 6, -198630844), a8 = J(a8, a5, a6, a7, Y[a0 + 7], 10, 1126891415), a7 = J(a7, a8, a5, a6, Y[a0 + 14], 15, -1416354905), a6 = J(a6, a7, a8, a5, Y[a0 + 5], 21, -57434055), a5 = J(a5, a6, a7, a8, Y[a0 + 12], 6, 1700485571), a8 = J(a8, a5, a6, a7, Y[a0 + 3], 10, -1894986606), a7 = J(a7, a8, a5, a6, Y[a0 + 10], 15, -1051523), a6 = J(a6, a7, a8, a5, Y[a0 + 1], 21, -2054922799), a5 = J(a5, a6, a7, a8, Y[a0 + 8], 6, 1873313359), a8 = J(a8, a5, a6, a7, Y[a0 + 15], 10, -30611744), a7 = J(a7, a8, a5, a6, Y[a0 + 6], 15, -1560198380), a6 = J(a6, a7, a8, a5, Y[a0 + 13], 21, 1309151649), a5 = J(a5, a6, a7, a8, Y[a0 + 4], 6, -145523070), a8 = J(a8, a5, a6, a7, Y[a0 + 11], 10, -1120210379), a7 = J(a7, a8, a5, a6, Y[a0 + 2], 15, 718787259), a6 = J(a6, a7, a8, a5, Y[a0 + 9], 21, -343485441), a5 = C(a5, a1), a6 = C(a6, a2), a7 = C(a7, a3), a8 = C(a8, a4);

    return [a5, a6, a7, a8];
&#125;

function O(Y) &#123;
    var Z,
        a0 = &quot;&quot;,
        a1 = 32 * Y[&quot;length&quot;];

    for (Z = 0; Z &lt; a1; Z += 8) a0 += String[&quot;fromCharCode&quot;](Y[Z &gt;&gt; 5] &gt;&gt;&gt; Z % 32 &amp; 255);

    return a0;
&#125;

function P(Y) &#123;
    var Z = &quot;0|1|4|2|3&quot;[&quot;split&quot;](&quot;|&quot;);
    var a0 = 0;

    while (!![]) &#123;
        switch (Z[a0++]) &#123;
            case &quot;0&quot;:
                var a1,
                    a2 = [];
                continue;

            case &quot;1&quot;:
                for (a2[(Y[&quot;length&quot;] &gt;&gt; 2) - 1] = void 0, a1 = 0; a1 &lt; a2[&quot;length&quot;]; a1 += 1) a2[a1] = 0;

                continue;

            case &quot;2&quot;:
                for (a1 = 0; a1 &lt; a3; a1 += 8) a2[a1 &gt;&gt; 5] |= (255 &amp; Y[&quot;charCodeAt&quot;](a1 / 8)) &lt;&lt; a1 % 32;

                continue;

            case &quot;3&quot;:
                return a2;

            case &quot;4&quot;:
                var a3 = 8 * Y[&quot;length&quot;];
                continue;
        &#125;

        break;
    &#125;
&#125;

function Q(Y) &#123;
    return O(N(P(Y), 8 * Y[&quot;length&quot;]));
&#125;

function R(Y) &#123;
    var Z,
        a0,
        a1 = &quot;0123456789abcdef&quot;,
        a2 = &quot;&quot;;

    for (a0 = 0; a0 &lt; Y[&quot;length&quot;]; a0 += 1) Z = Y[&quot;charCodeAt&quot;](a0), a2 += a1[&quot;charAt&quot;](Z &gt;&gt;&gt; 4 &amp; 15) + a1[&quot;charAt&quot;](15 &amp; Z);

    return a2;
&#125;

function S(Y) &#123;
    return unescape(encodeURIComponent(Y));
&#125;

function T(Y) &#123;
    return Q(S(Y));
&#125;

function U(Y) &#123;
    return R(T(Y));
&#125;

function V(Y, Z, a0) &#123;
    M();
    return Z ? a0 ? H(Z, Y) : y(Z, Y) : a0 ? T(Y) : U(Y);
&#125;

function W(Y, Z) &#123;
    var cookie = &quot;m&quot; + M() + &quot;=&quot; + V(Y) + &quot;|&quot; + Y + &quot;; path=/&quot;;
    console_hk(cookie);
&#125;

function X(Y, Z) &#123;
    return Date[&quot;parse&quot;](new Date());
&#125;

W(X());
</code></pre>
<blockquote>
<p>补充：上述只是对简单的ob进行了一个还原，由于其控制流不是很复杂，所以没必要进一步还原控制流，同时，在解密函数这部分，有的是解密数组，有的是解密函数，灵活变通即可。</p>
</blockquote>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="某验"><a href="#某验" class="headerlink" title="某验"></a>某验</h4><h5 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h5><p>受害者地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vZGVtby9zbGlkZS1iaW5kLmh0bWw=">https://www.geetest.com/demo/slide-bind.html</span></p>
<p>将代码放入在线网站解析，我们可以</p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-04-30 22:59:56" itemprop="dateModified" datetime="2022-04-30T22:59:56+08:00">2022-04-30</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="Mr2 WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="Mr2 Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="Mr2 PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>Mr2 <i class="ic i-at"><em>@</em></i>菜b的爬虫记录
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://yida506.github.io/2021/11/28/ast/" title="AST语法树">http://yida506.github.io/2021/11/28/ast/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2021/11/14/js%E9%80%86%E5%90%91/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfb3vzhj20zk0m8wny.jpg" title="js逆向">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> JS逆向</span>
  <h3>js逆向</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2021/12/18/%E8%A1%A5%E7%8E%AF%E5%A2%83/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclxfdlttj20zk0m8npd.jpg" title="补环境">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> JS逆向</span>
  <h3>补环境</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#AST%E8%AF%AD%E6%B3%95%E6%A0%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">AST语法树介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8Cbabel"><span class="toc-number">2.</span> <span class="toc-text">本地运行babel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#parser%E7%94%A8%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">parser用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#traverse%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">traverse用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#generator%E7%94%A8%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">generator用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#types%E7%94%A8%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">types用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">2.5.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AST%E6%8F%92%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">AST插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B7%B7%E6%B7%86"><span class="toc-number">3.1.</span> <span class="toc-text">常量混淆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8A%98%E5%8F%A0"><span class="toc-number">3.2.</span> <span class="toc-text">常量折叠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%98%E5%8E%9F"><span class="toc-number">3.3.</span> <span class="toc-text">函数还原</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">控制流平坦化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%8E%A2OB%E6%B7%B7%E6%B7%86"><span class="toc-number">4.</span> <span class="toc-text">初探OB混淆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AST%E8%A7%A3OB%E6%B7%B7%E6%B7%86-lowlevel"><span class="toc-number">4.1.</span> <span class="toc-text">AST解OB混淆(lowlevel)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-%E6%9F%90%E6%AF%94%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98"><span class="toc-number">4.2.</span> <span class="toc-text">实战(某比赛第二题)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#step1%EF%BC%9A%E8%A7%A3%E5%AF%86%E5%87%BD%E6%95%B0%E5%86%85%E5%AD%98%E5%86%99%E5%85%A5"><span class="toc-number">4.2.1.</span> <span class="toc-text">step1：解密函数内存写入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#step2%EF%BC%9A%E8%A7%A3%E5%AF%86%E5%87%BD%E6%95%B0%E8%BF%98%E5%8E%9F"><span class="toc-number">4.2.2.</span> <span class="toc-text">step2：解密函数还原</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#step3%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%BD%AE%E6%8D%A2%E4%B8%8E%E5%86%99%E5%85%A5"><span class="toc-number">4.2.3.</span> <span class="toc-text">step3：对象置换与写入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#step4%EF%BC%9A%E6%89%AB%E5%B0%BE%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.2.4.</span> <span class="toc-text">step4：扫尾工作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">5.</span> <span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%90%E9%AA%8C"><span class="toc-number">5.1.</span> <span class="toc-text">某验</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.1.1.</span> <span class="toc-text">代码分析</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li class="active"><a href="/2021/11/28/ast/" rel="bookmark" title="AST语法树">AST语法树</a></li><li><a href="/2021/12/29/ast%E8%BF%9B%E9%98%B6/" rel="bookmark" title="ast进阶">ast进阶</a></li><li><a href="/2022/01/01/ast%E6%80%9D%E6%83%B3/" rel="bookmark" title="ast思想">ast思想</a></li><li><a href="/2022/02/10/ti%E8%BF%98%E5%8E%9F/" rel="bookmark" title="ti还原1">ti还原1</a></li><li><a href="/2022/02/20/ti%E8%BF%98%E5%8E%9F2/" rel="bookmark" title="ti还原2">ti还原2</a></li><li><a href="/2022/03/11/ast-tools%E8%A7%A3%E8%AF%BB/" rel="bookmark" title="ast_tools解读">ast_tools解读</a></li><li><a href="/2022/03/13/ali/" rel="bookmark" title="ali">ali</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="Mr2"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">Mr2</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">41</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">20</span>
        <span class="name">categories</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2021/11/14/js%E9%80%86%E5%90%91/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2021/12/18/%E8%A1%A5%E7%8E%AF%E5%A2%83/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="In 机器学习">机器学习</a>
</div>

    <span><a href="/2022/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%8B%E7%BB%8D/" title="数据挖掘介绍">数据挖掘介绍</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/app%E9%80%86%E5%90%91/" title="In app逆向">app逆向</a>
</div>

    <span><a href="/2022/05/03/Ratel/" title="Ratel">Ratel</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/app%E9%80%86%E5%90%91/" title="In app逆向">app逆向</a>
</div>

    <span><a href="/2022/04/21/Frida/" title="Frida">Frida</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/app%E9%80%86%E5%90%91/" title="In app逆向">app逆向</a>
</div>

    <span><a href="/2022/04/19/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" title="静态分析">静态分析</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/JSRPC/" title="In JSRPC">JSRPC</a>
</div>

    <span><a href="/2022/03/21/%E6%8A%96%E9%9F%B3web/" title="抖音web">抖音web</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B8%93%E9%A2%98/" title="In 验证码专题">验证码专题</a>
</div>

    <span><a href="/2022/01/09/%E9%AA%8C%E8%AF%81%E7%A0%81/" title="验证码">验证码</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/ast/" title="In ast">ast</a>
</div>

    <span><a href="/2022/02/10/ti%E8%BF%98%E5%8E%9F/" title="ti还原1">ti还原1</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/JS%E9%80%86%E5%90%91/" title="In JS逆向">JS逆向</a>
</div>

    <span><a href="/2021/12/28/%E5%8F%8D%E8%B0%83%E8%AF%95/" title="反调试">反调试</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%A1%86%E6%9E%B6/" title="In 框架">框架</a>
</div>

    <span><a href="/2022/02/02/Framework/" title="Framework">Framework</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Java/" title="In Java">Java</a>
</div>

    <span><a href="/2022/05/15/java%E5%9F%BA%E7%A1%80/" title="java基础">java基础</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mr2 @ Yume Shoka</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2021/11/28/ast/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
