{
    "version": "https://jsonfeed.org/version/1",
    "title": "菜b的爬虫记录 • All posts by \"app进阶\" tag",
    "description": "",
    "home_page_url": "http://yida506.github.io",
    "items": [
        {
            "id": "http://yida506.github.io/2022/08/22/App%E5%8F%82%E6%95%B0%E5%AE%9A%E4%BD%8D/",
            "url": "http://yida506.github.io/2022/08/22/App%E5%8F%82%E6%95%B0%E5%AE%9A%E4%BD%8D/",
            "title": "App参数定位",
            "date_published": "2022-08-22T13:17:11.000Z",
            "content_html": "<h3 id=\"参数定位\"><a href=\"#参数定位\" class=\"headerlink\" title=\"参数定位\"></a>参数定位</h3><p>​        对于一个app来讲，我们往往要获得的是其加密参数，一般来讲，都是通过对网络请求抓包，然后分析参数逻辑，确定加密位置，但是，这样有一个弊端，假使存在了针对抓包的对抗(sslping等)，就会增加定位参数的逻辑成本，基于此，本文提供了另一种思路用于定位参数逻辑。</p>\n<h5 id=\"Intent\"><a href=\"#Intent\" class=\"headerlink\" title=\"Intent\"></a>Intent</h5><p>​        一般来讲，页面跳转都存在序列化-&gt;反序列化的逻辑。</p>\n<pre><code class=\"lang-java\">btnTwo.setOnClickListener(new View.OnClickListener()&#123;\n            @Override\n            public void onClick(View v) &#123;\n                Intent intent = new Intent(MainActivity.this, SecondActivity.class);\n                // 创建一个Bundle对象封装数据\n                Bundle data = new Bundle();\n                data.putInt(&quot;age&quot;,18);\n                data.putString(&quot;name&quot;, &quot;Jack&quot;);\n                intent.putExtra(&quot;data&quot;, data);\n                startActivity(intent);\n            &#125;\n        &#125;);\n// 第二个页面\nBundle data = getIntent().getBundleExtra(&quot;data&quot;);\nint id = data.getInt(&quot;age&quot;);\n</code></pre>\n<p>​        这里的逻辑是给按钮绑定点击事件，然后，<code>startActivity</code>就是页面跳转的逻辑，然后就把第一页的数据传到了第二页。</p>\n<pre><code class=\"lang-javascript\">// 打印调用堆栈\nfunction printStack() &#123;\n    Java.perform(function () &#123;\n        var Exception = Java.use(&quot;java.lang.Exception&quot;);\n        var ins = Exception.$new(&quot;Exception&quot;);\n        var straces = ins.getStackTrace();\n        if (straces != undefined &amp;&amp; straces != null) &#123;\n            var strace = straces.toString();\n            var replaceStr = strace.replace(/,/g, &quot;\\r\\n&quot;);\n            console.log(&quot;=============================Stack strat=======================&quot;);\n            console.log(replaceStr);\n            console.log(&quot;=============================Stack end=======================\\r\\n&quot;);\n            Exception.$dispose();\n        &#125;\n    &#125;);\n&#125;\n\n\n// hook intent\nfunction hookintent() &#123;\n    Java.perform(function()&#123;\n        let Intent = Java.use(&quot;android.content.Intent&quot;);\n        // 要注意这里的重载类型\n        Intent.putExtra.overload(&#39;java.lang.String&#39;, &#39;android.os.Bundle&#39;).implementation = function(a, b)&#123;\n            console.log(&quot;hook intent&quot;)\n            printStack()\n            return this.putExtra(a, b);\n        &#125;;\n\n    &#125;)\n&#125;;\n</code></pre>\n<h5 id=\"TextView\"><a href=\"#TextView\" class=\"headerlink\" title=\"TextView\"></a>TextView</h5><p>​        第二种就是Hook Android 原生组件，因为，数据如何传输，最终还是会渲染到页面上，这样只需要，hook对应的组件，打印调用堆栈，就能定位到入口。</p>\n<pre><code class=\"lang-javascript\">// hook setText\nfunction hooksetText()&#123;\n    Java.perform(function()&#123;\n        let TextView = Java.use(&quot;android.widget.TextView&quot;);\n        var stringClzz = Java.use(&#39;java.lang.String&#39;);\n        TextView.setText.overload(&#39;java.lang.CharSequence&#39;).implementation = function(a)&#123;\n            console.log(&quot;hook text View&quot;)\n            var obj1= Java.cast(a, stringClzz); // 类型转化\n            console.log(obj1);\n            if( obj1.indexOf(&quot;test&quot;) &gt; -1) &#123;\n                printStack();\n            &#125;;\n            return this.setText(a);\n        &#125;;\n\n    &#125;);\n&#125;;\n</code></pre>\n<blockquote>\n<p>缺点就是，只能应对原生组件</p>\n</blockquote>\n<h5 id=\"Dialog\"><a href=\"#Dialog\" class=\"headerlink\" title=\"Dialog\"></a>Dialog</h5><p>​        第三种，就是hook弹窗。</p>\n<pre><code class=\"lang-javascript\">function hookdialog()&#123;\n    Java.perform(function()&#123;\n        let Builder = Java.use(&quot;androidx.appcompat.app.AlertDialog$Builder&quot;);\n        var stringClzz = Java.use(&#39;java.lang.String&#39;);\n        console.log(&#39;hook dialog&#39;);\n        Builder.setMessage.overload(&#39;java.lang.CharSequence&#39;).implementation = function(a)&#123;\n            console.log(&quot;hook dialog1&quot;);\n            var obj1= Java.cast(a, stringClzz); // 类型转化\n            console.log(obj1);\n            printStack()\n            return this.setMessage(a);\n        &#125;;\n\n    &#125;);\n&#125;;\n</code></pre>\n",
            "tags": [
                "app进阶"
            ]
        }
    ]
}