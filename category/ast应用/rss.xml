<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>菜b的爬虫记录 • Posts by &#34;ast应用&#34; category</title>
        <link>http://yida506.github.io</link>
        <description></description>
        <language>en</language>
        <pubDate>Thu, 05 May 2022 19:16:46 +0800</pubDate>
        <lastBuildDate>Thu, 05 May 2022 19:16:46 +0800</lastBuildDate>
        <item>
            <guid isPermalink="true">http://yida506.github.io/2022/05/05/ast%E8%A7%A3vmp/</guid>
            <title>ast解vmp</title>
            <link>http://yida506.github.io/2022/05/05/ast%E8%A7%A3vmp/</link>
            <pubDate>Thu, 05 May 2022 19:16:46 +0800</pubDate>
            <description><![CDATA[ &lt;h4 id=&#34;知乎vmp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#知乎vmp&#34;&gt;#&lt;/a&gt; 知乎 vmp&lt;/h4&gt;
&lt;h5 id=&#34;大致流程&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#大致流程&#34;&gt;#&lt;/a&gt; 大致流程&lt;/h5&gt;
&lt;p&gt;首先会初始化参数，由于函数只传入 e 进来 (为一个大字符串)，所以 t、n 会根据条件赋予初值 0、和一个空数组，接着会进入 this.D 这个方法中，主要是讲这个初始大字符串传入，然后，对其进行一系列的分割，计算的操作，生成两个大数组，分别绑定在 this.G 和 this.b 上，这对应的是初始化的流程。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;ast%E8%A7%A3vmp/image-20220505210459984.png&#34; alt=&#34;image-20220505210459984&#34;&gt;&lt;/p&gt;
&lt;p&gt;接着就是进入 for 循环内部，可以清晰的看到有三个明显的位置，其中 r=this.G [this.C++]，是做了一个从数组中取数的操作，接着这个 if 判断用于限定终止条件，很明显，这个 r 在每一步 for 循环中都会 + 1, 直到数组值越界结束 (对应的这个 396 个流程的 this.G 的数组的长度)，接着会将 r 这个值，传入 this.e 这个方法中。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;ast%E8%A7%A3vmp/image-20220505211331204.png&#34; alt=&#34;image-20220505211331204&#34;&gt;&lt;/p&gt;
&lt;p&gt;跟进去，发现，这里有个移位操作，然后会生成一个值，然后这个值会影响走入不同的分支&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;ast%E8%A7%A3vmp/image-20220505211820473.png&#34; alt=&#34;image-20220505211820473&#34;&gt;&lt;/p&gt;
&lt;p&gt;this.J 为一个具有 16 个键值的对象，这里的键为 14 对应的值为 u，然后就进入了 u 函数中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是说，大数组中的每一个值，都会有唯一的一个函数与其绑定，同时其绑定由其值经过一个移位运算得到，暂时将这些函数统称为选择函数 (会计算一些初始值)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;ast%E8%A7%A3vmp/image-20220505212416451.png&#34; alt=&#34;image-20220505212416451&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来会生成一个 this.h，目前这个是干什么的，还不得而知。&lt;/p&gt;
&lt;p&gt;最后就进入了一个这样的函数中，可以看到，&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;ast%E8%A7%A3vmp/image-20220505212535506.png&#34; alt=&#34;image-20220505212535506&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时的 e 指代的是一个对象，然后 t 治理指代刚刚生成的 u {h:7}, 然后给与 n 赋予了一个 [0] 数组。&lt;/p&gt;
&lt;p&gt;然后将 e.k 中的值 push 到 n 中，接着，将 e.r [3] 赋予一个刚生成的函数，这时候，this.r 中的数组就从一个 [0,0,0,0] 变成了 [0,0,0,function];&lt;/p&gt;
&lt;p&gt;接着继续跟，我们绕过选择函数后，发现，进入了一个 switchcase 控制流，在这里，我们发现&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;ast%E8%A7%A3vmp/image-20220505214343034.png&#34; alt=&#34;image-20220505214343034&#34;&gt;&lt;/p&gt;
&lt;p&gt;每一个 this.t 的值，会决定接下来的流程，也就是说，this.t 会进行一个操作，选择进行什么运算。&lt;/p&gt;
&lt;p&gt;这一步实际上是将刚刚生成的哪个函数 push 到数组中，&lt;/p&gt;
&lt;p&gt;第三步是将小数组中的乱码做一个解密的操作，然后也 push 到 e.f 中。&lt;/p&gt;
&lt;p&gt;第四步是将 e.f 中的数取出来，然后 push 了个空对象进去，&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;ast%E8%A7%A3vmp/image-20220505215521026.png&#34; alt=&#34;image-20220505215521026&#34;&gt;&lt;/p&gt;
&lt;p&gt;第五步，又是解密操作，这一步生成了一个 _ encrypt 字符，然后将对象中添加一个键值对，键为_encrypt，值为一开始的那个函数，这样就生成了第一个__g.encrypt 的函数，接着在跟进去就发现，索引值是从 7 开始的了。&lt;/p&gt;
&lt;p&gt;也就是说前六步的流程就是给与__g 这个对象，赋值了一个函数，然后，当我们在传入参数的时候，就会又进入其逻辑，至此，我们已经知道了他的具体操作，但是我们要如何对其进行还原呢？&lt;/p&gt;
&lt;p&gt;在对 ali 等控制流进行还原的时候，我们都是通过从起始流程出发，不断的对其进行节点合并等操作，但是那局限于代码已知的情况，但是这里，进行的操作往往都是虚拟化的 (完全是通过对数组的处理进行的操作)。&lt;/p&gt;
&lt;p&gt;同时，通过对上述的观察，我们发现本质上都是在通过其余的指令对那个 4 位的数组进行操作，假使我们能根据他的流程，找到对应的索引数，也就是要操作的变量，然后在将其代码进行生成，那么就同样可以达到代码顺序执行的操作。&lt;/p&gt;
&lt;h5 id=&#34;还原思路&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#还原思路&#34;&gt;#&lt;/a&gt; 还原思路&lt;/h5&gt;
&lt;p&gt;要对上述进行一个还原，首先要做的，就是构建修饰代码，因为，我们在其中，发现有值生成的部分，有字符串解密的过程，我们希望生成的代码，尽可能简洁，不被任何干扰项影响。&lt;/p&gt;
&lt;p&gt;在 javascript 中，运行一串 js 代码，会执行词法分析 -&amp;gt; 句法分析 -&amp;gt; 解析成 ast 语法树 -&amp;gt; 解释器解析这四个步骤 (个人理解)，vm 防护的本质就是，将代码逻辑隐藏到数组中，通过对数组不断处理，来达到生成加密参数的流程，这样一来，极大的增加了调试成本，如果只把加密逻辑使用 vmp 实现，那么对 web 端的影响微乎其微。&lt;/p&gt;
&lt;p&gt;个人认为，将其实际的代码还原出具有实际逻辑的办法，只有针对其流程中的每一个 case 进行分析，然后看透其本质，最终通过 ast，生成代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;与还原 switch-case 类似，但是唯一不同在于，要人工分析每一个步骤，然后生成最简代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;还原就是闲的蛋疼&lt;/strong&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
